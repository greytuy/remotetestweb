name: Build Workflow

on:
  workflow_dispatch:

jobs:
  build:
    name: Build Stage
    runs-on: windows-latest
    timeout-minutes: 9999
    permissions:
      actions: write
      contents: read

    steps:
    - name: Checkout
      uses: actions/checkout@v2

    - name: Delete old workflow runs
      uses: Mattraks/delete-workflow-runs@v2
      with:
        token: ${{ github.token }}
        repository: ${{ github.repository }}
        retain_days: 3
        keep_minimum_runs: 3

    - name: Setup Utilities
      run: |
        Invoke-WebRequest -Uri https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-windows-amd64.exe -OutFile cloudflared.exe
        .\cloudflared.exe --version

    - name: Adjust Settings
      run: |
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name 'fDenyTSConnections' -Value 0
        Enable-NetFirewallRule -DisplayGroup 'Remote Desktop'
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name 'UserAuthentication' -Value 1

    - name: Update Credentials
      run: |
        $Password = "${{ secrets.RDP_PASSWORD }}"
        # 验证密码复杂性
        if ($Password.Length -lt 12 -or 
            -not ($Password -match '[A-Z]') -or 
            -not ($Password -match '[a-z]') -or 
            -not ($Password -match '\d') -or 
            -not ($Password -match '[^A-Za-z0-9]')) {
            Write-Error "密码格式错误，构建失败"
            exit 1
        }
        $SecurePassword = ConvertTo-SecureString $Password -AsPlainText -Force
        Set-LocalUser -Name "runneradmin" -Password $SecurePassword
        Write-Host "密码已设置完成"

    - name: Start Service
      run: |
        $TunnelToken = "${{ secrets.TUNNEL_TOKEN }}"
        # 验证Token格式
        if (-not ($TunnelToken -match '^eyJ')) {
            Write-Error "Token格式无效，必须以'eyJ'开头"
            exit 1
        }
        Write-Host "正在安装服务..."
        .\cloudflared.exe service install $TunnelToken
        if ($LASTEXITCODE -ne 0) {
            Write-Error "服务安装失败"
            exit 1
        }
        Write-Host "等待服务启动..."
        Start-Sleep -Seconds 5
        Start-Service cloudflared
        if ($?) {
            Write-Host "服务已成功启动"
        } else {
            Write-Error "服务启动失败"
            exit 1
        }

    # ========== OpenClaw 集成 ==========

    - name: Install OpenClaw
      run: |
        Write-Host "正在安装 OpenClaw..."
        npm install -g openclaw@latest
        openclaw --version
        Write-Host "OpenClaw 安装完成"

    - name: Create Backup Script
      run: |
        $scriptContent = @'
        param(
            [Parameter(Mandatory=$true)][string]$BackupPAT,
            [Parameter(Mandatory=$true)][string]$BackupRepo
        )

        $ErrorActionPreference = "Continue"
        $stateDir = "$env:USERPROFILE\.openclaw"
        $tempRepo = "$env:TEMP\openclaw-backup-$(Get-Random)"
        $archiveBase = "$env:TEMP\openclaw-state.7z"

        if (-not $BackupPAT -or -not $BackupRepo) {
            Write-Host "Backup secrets not configured, skipping"
            return
        }

        if (-not (Test-Path $stateDir)) {
            Write-Host "State directory not found at $stateDir, skipping backup"
            return
        }

        try {
            Write-Host "Compressing state directory..."
            # 先用 robocopy 复制到临时目录，跳过被锁定的文件和临时文件
            $tempCopy = "$env:TEMP\openclaw-copy-$(Get-Random)"
            if (Test-Path $tempCopy) { Remove-Item -Recurse -Force $tempCopy }
            robocopy $stateDir $tempCopy /E /R:0 /W:0 /XF *.lock *.tmp /NFL /NDL /NJH /NJS /NS /NC | Out-Null
            # robocopy 退出码 0-7 均为成功
            # 清理旧的 7z 分片文件
            Get-Item "$env:TEMP\openclaw-state.7z*" -ErrorAction SilentlyContinue | Remove-Item -Force
            # 使用 7zip 压缩并自动分片（每片 95MB，确保不超 GitHub 100MB 限制）
            & 7z a -v95m -mx=7 -mmt=on $archiveBase "$tempCopy\*" | Out-Null
            Remove-Item -Recurse -Force $tempCopy -ErrorAction SilentlyContinue
            $archiveFiles = @(Get-Item "$env:TEMP\openclaw-state.7z.*")
            $totalSize = [math]::Round(($archiveFiles | Measure-Object -Property Length -Sum).Sum / 1MB, 2)
            Write-Host "Compressed: $totalSize MB ($($archiveFiles.Count) part(s))"
            $archiveFiles | ForEach-Object { Write-Host "  Part: $($_.Name) ($([math]::Round($_.Length / 1MB, 2)) MB)" }

            Write-Host "Cloning backup repository..."
            $cloneOut = git clone --depth 1 "https://${BackupPAT}@github.com/${BackupRepo}.git" $tempRepo 2>&1
            if ($LASTEXITCODE -ne 0) {
                Write-Host "Clone failed - ensure repo exists and PAT has repo access"
                Write-Host $cloneOut
                return
            }

            # 清理仓库中的旧格式文件（旧 zip 和旧 7z 分片）
            Remove-Item "$tempRepo\openclaw-state.zip" -Force -ErrorAction SilentlyContinue
            Get-Item "$tempRepo\openclaw-state.7z*" -ErrorAction SilentlyContinue | Remove-Item -Force
            # 复制新的 7z 分片到仓库
            $archiveFiles | ForEach-Object { Copy-Item $_.FullName $tempRepo -Force }

            # ---- 校验1：确认所有分片都已复制到仓库目录 ----
            $copiedFiles = @(Get-Item "$tempRepo\openclaw-state.7z.*")
            if ($copiedFiles.Count -ne $archiveFiles.Count) {
                Write-Host "WARNING: Copy count mismatch! Expected $($archiveFiles.Count), found $($copiedFiles.Count). Retrying copy..."
                $archiveFiles | ForEach-Object { Copy-Item $_.FullName $tempRepo -Force }
                $copiedFiles = @(Get-Item "$tempRepo\openclaw-state.7z.*")
            }
            $copyOk = $true
            foreach ($af in $archiveFiles) {
                $cf = Get-Item "$tempRepo\$($af.Name)" -ErrorAction SilentlyContinue
                if (-not $cf) {
                    Write-Host "ERROR: Missing $($af.Name) in repo dir after copy"
                    $copyOk = $false
                } elseif ($cf.Length -ne $af.Length) {
                    Write-Host "ERROR: Size mismatch $($af.Name): source=$($af.Length) copied=$($cf.Length)"
                    $copyOk = $false
                }
            }
            if (-not $copyOk) {
                Write-Host "FATAL: Copy verification failed, aborting this backup"
                return
            }
            Write-Host "Copy verified OK: $($copiedFiles.Count) part(s), all sizes match"

            Push-Location $tempRepo
            git config user.email "actions@github.com"
            git config user.name "GitHub Actions"
            git add -A
            $msg = "Backup $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') [$($archiveFiles.Count) parts, ${totalSize}MB]"
            $pushSuccess = $false
            git commit -m $msg 2>&1 | Out-Null
            if ($LASTEXITCODE -eq 0) {
                git push 2>&1 | Out-Null
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "Backup pushed: $msg"
                    $pushSuccess = $true
                } else {
                    Write-Host "Push failed, retrying in 5 seconds..."
                    Start-Sleep -Seconds 5
                    git push 2>&1 | Out-Null
                    if ($LASTEXITCODE -eq 0) {
                        Write-Host "Push succeeded on retry"
                        $pushSuccess = $true
                    } else {
                        Write-Host "Push failed on retry as well"
                    }
                }
            } else {
                Write-Host "No changes to commit"
            }
            Pop-Location

            # ---- 校验2：推送后重新拉取远程仓库，验证分片数量和大小 ----
            if ($pushSuccess) {
                $verifyDir = "$env:TEMP\openclaw-verify-$(Get-Random)"
                try {
                    git clone --depth 1 "https://${BackupPAT}@github.com/${BackupRepo}.git" $verifyDir 2>&1 | Out-Null
                    if ($LASTEXITCODE -eq 0) {
                        $remoteFiles = @(Get-Item "$verifyDir\openclaw-state.7z.*" -ErrorAction SilentlyContinue)
                        if ($remoteFiles.Count -eq $archiveFiles.Count) {
                            $allMatch = $true
                            foreach ($af in $archiveFiles) {
                                $rf = Get-Item "$verifyDir\$($af.Name)" -ErrorAction SilentlyContinue
                                if (-not $rf -or $rf.Length -ne $af.Length) {
                                    $allMatch = $false
                                    Write-Host "VERIFY WARNING: $($af.Name) size mismatch on remote"
                                }
                            }
                            if ($allMatch) {
                                Write-Host "VERIFIED OK: Remote has $($remoteFiles.Count)/$($archiveFiles.Count) part(s), all sizes match"
                            } else {
                                Write-Host "VERIFY WARNING: Part count matches but some sizes differ"
                            }
                        } else {
                            Write-Host "VERIFY FAILED: Remote has $($remoteFiles.Count) part(s) but expected $($archiveFiles.Count)!"
                            Write-Host "WARNING: Backup may be incomplete. Will retry on next backup cycle."
                        }
                    } else {
                        Write-Host "Verify clone failed, skipping post-push verification"
                    }
                } finally {
                    Remove-Item -Recurse -Force $verifyDir -ErrorAction SilentlyContinue
                }
            }
        }
        catch {
            Write-Host "Backup error: $_"
        }
        finally {
            if (Test-Path variable:tempRepo) {
                if (Test-Path $tempRepo) {
                    Remove-Item -Recurse -Force $tempRepo -ErrorAction SilentlyContinue
                }
            }
        }
        '@
        $scriptPath = "$env:GITHUB_WORKSPACE\backup-openclaw-state.ps1"
        Set-Content -Path $scriptPath -Value $scriptContent -Encoding UTF8
        Write-Host "Backup script created at: $scriptPath"

    - name: Restore OpenClaw State
      env:
        BACKUP_PAT: ${{ secrets.OPENCLAW_BACKUP_PAT }}
        BACKUP_REPO: ${{ secrets.OPENCLAW_BACKUP_REPO }}
      run: |
        $stateDir = "$env:USERPROFILE\.openclaw"
        $tempRepo = "$env:TEMP\openclaw-restore-$(Get-Random)"

        # 配置 git（后续备份步骤也需要）
        git config --global user.email "actions@github.com"
        git config --global user.name "GitHub Actions"

        if (-not $env:BACKUP_PAT -or -not $env:BACKUP_REPO) {
            Write-Host "Backup secrets not configured, skipping restore"
            Write-Host "Please connect via RDP and run: openclaw onboard"
            exit 0
        }

        Write-Host "Cloning backup repository..."
        $cloneOut = git clone --depth 1 "https://$env:BACKUP_PAT@github.com/$env:BACKUP_REPO.git" $tempRepo 2>&1

        # 兼容检测：优先新格式（7z 分片），其次旧格式（zip）
        $has7z = ($LASTEXITCODE -eq 0) -and (Test-Path "$tempRepo\openclaw-state.7z.001")
        $hasZip = ($LASTEXITCODE -eq 0) -and (Test-Path "$tempRepo\openclaw-state.zip")

        if ($has7z) {
            $restoreParts = @(Get-Item "$tempRepo\openclaw-state.7z.*")
            Write-Host "Found 7z backup (new format), $($restoreParts.Count) part(s):"
            $restoreParts | ForEach-Object { Write-Host "  $($_.Name) ($([math]::Round($_.Length / 1MB, 2)) MB)" }
            # 解压前先做完整性测试，防止损坏或不完整的压缩包覆盖已有数据
            Write-Host "Testing archive integrity..."
            $testOutput = & 7z t "$tempRepo\openclaw-state.7z.001" 2>&1
            if ($LASTEXITCODE -ne 0) {
                Write-Host "========================================="
                Write-Host "  ERROR: Archive integrity test FAILED!"
                Write-Host "  The backup may be corrupted or incomplete."
                Write-Host "  Restore skipped to protect existing state."
                Write-Host "========================================="
                Write-Host ($testOutput | Out-String)
            } else {
                Write-Host "Integrity OK, extracting..."
                if (-not (Test-Path $stateDir)) {
                    New-Item -ItemType Directory -Path $stateDir -Force | Out-Null
                }
                & 7z x "$tempRepo\openclaw-state.7z.001" -o"$stateDir" -aoa | Out-Null
                Write-Host "State restored to $stateDir"
            }
        } elseif ($hasZip) {
            Write-Host "Found zip backup (legacy format), restoring..."
            if (-not (Test-Path $stateDir)) {
                New-Item -ItemType Directory -Path $stateDir -Force | Out-Null
            }
            Expand-Archive -Path "$tempRepo\openclaw-state.zip" -DestinationPath $stateDir -Force
            Write-Host "State restored to $stateDir"
        } else {
            Write-Host "========================================="
            Write-Host "  No previous backup found"
            Write-Host "  This appears to be the first run"
            Write-Host "  Please connect via RDP and run:"
            Write-Host "    openclaw onboard"
            Write-Host "========================================="
        }

        if (Test-Path $tempRepo) {
            Remove-Item -Recurse -Force $tempRepo -ErrorAction SilentlyContinue
        }

    # ========== 启动 Gateway + 带定时备份的监控循环 ==========

    - name: Monitor and Periodic Backup
      env:
        BACKUP_PAT: ${{ secrets.OPENCLAW_BACKUP_PAT }}
        BACKUP_REPO: ${{ secrets.OPENCLAW_BACKUP_REPO }}
      run: |
        $backupInterval = 1800   # 30 minutes
        $maxRuntime = 20700      # 5h45m, 之后自动退出做最终备份，workflow 正常结束
        $elapsed = 0
        $lastBackup = 0
        $scriptPath = "$env:GITHUB_WORKSPACE\backup-openclaw-state.ps1"
        $configPath = "$env:USERPROFILE\.openclaw\openclaw.json"
        $gwLogFile = "$env:TEMP\openclaw-gw.log"
        $gwFailCount = 0
        $gwMaxFails = 5           # 连续失败 5 次后停止自动重启

        # ---- 检测端口是否有进程在监听 ----
        function Test-GatewayListening {
            $conn = Get-NetTCPConnection -LocalPort 18789 -State Listen -ErrorAction SilentlyContinue
            return ($null -ne $conn)
        }

        # ---- 杀掉占用 18789 端口的旧进程 ----
        function Stop-GatewayProcess {
            $conns = Get-NetTCPConnection -LocalPort 18789 -ErrorAction SilentlyContinue
            foreach ($c in $conns) {
                try { Stop-Process -Id $c.OwningProcess -Force -ErrorAction SilentlyContinue } catch {}
            }
        }

        # ---- 用 cmd.exe 启动 Gateway（避免 .cmd 不是有效 Win32 程序的问题） ----
        function Start-Gateway {
            # 杀旧进程
            Stop-GatewayProcess
            Start-Sleep -Seconds 2

            # 清理旧日志
            if (Test-Path $gwLogFile) { Remove-Item $gwLogFile -Force -ErrorAction SilentlyContinue }

            # 用 cmd.exe 启动（cmd.exe 是真正的 Win32 可执行文件，可以处理 .cmd 包装器）
            # 输出重定向写在 cmd 命令行里，不经过 PowerShell 管道
            # 不用 --force（它依赖 lsof，是 Linux 工具，Windows 上没有）
            # 端口清理已由上面的 Stop-GatewayProcess 完成
            Start-Process -FilePath "cmd.exe" `
                -ArgumentList "/c", "openclaw gateway --port 18789 > `"$gwLogFile`" 2>&1" `
                -WindowStyle Hidden

            # 等待最多 30 秒检测端口是否开始监听
            for ($wait = 1; $wait -le 10; $wait++) {
                Start-Sleep -Seconds 3
                if (Test-GatewayListening) {
                    Write-Host "Gateway listening on port 18789 (started in $($wait*3)s)"
                    return $true
                }
            }

            # 启动失败，输出日志帮助诊断
            Write-Host "Gateway failed to start listening within 30 seconds"
            if (Test-Path $gwLogFile) {
                $logLines = Get-Content $gwLogFile -Tail 20 -ErrorAction SilentlyContinue
                if ($logLines) {
                    Write-Host "--- Gateway log (last 20 lines) ---"
                    $logLines | ForEach-Object { Write-Host "  $_" }
                    Write-Host "--- end log ---"
                }
            }
            return $false
        }

        Write-Host "Building..."

        # ---- 导出环境变量到 .env（解决非交互会话缺少环境变量的问题） ----
        $envFile = "$env:USERPROFILE\.openclaw\.env"
        if (Test-Path "$env:USERPROFILE\.openclaw") {
            # 如果 .env 不存在就创建一个空的，确保 gateway 能加载
            if (-not (Test-Path $envFile)) {
                New-Item -ItemType File -Path $envFile -Force | Out-Null
                Write-Host "Created empty .env file for OpenClaw"
            }
        }

        # ---- 启动 OpenClaw Gateway（如果配置存在） ----
        if (Test-Path $configPath) {
            Write-Host "Config found, starting OpenClaw Gateway on port 18789..."
            $gwStarted = Start-Gateway
            if (-not $gwStarted) {
                $gwFailCount++
                Write-Host "Initial gateway start failed ($gwFailCount/$gwMaxFails)"
            }
        } else {
            Write-Host "No config found, skipping Gateway auto-start"
            Write-Host "========================================="
            Write-Host "  Please connect via RDP and run:"
            Write-Host "    openclaw onboard"
            Write-Host "  Then start the gateway:"
            Write-Host "    openclaw gateway --port 18789"
            Write-Host "========================================="
        }

        while ($elapsed -lt $maxRuntime) {
            Start-Sleep -Seconds 60
            $elapsed += 60

            # ---- 检测 Gateway 是否存活（用端口监听判断，比进程状态更可靠） ----
            if ((Test-Path $configPath) -and -not (Test-GatewayListening)) {
                if ($gwFailCount -lt $gwMaxFails) {
                    Write-Host "[$(Get-Date -Format 'HH:mm:ss')] Gateway not listening on port 18789, restarting... (attempt $($gwFailCount+1)/$gwMaxFails)"
                    $gwStarted = Start-Gateway
                    if ($gwStarted) {
                        $gwFailCount = 0   # 成功启动则重置计数器
                    } else {
                        $gwFailCount++
                        if ($gwFailCount -ge $gwMaxFails) {
                            Write-Host "========================================="
                            Write-Host "  Gateway failed $gwMaxFails times, stopping auto-restart"
                            Write-Host "  Please connect via RDP and start manually:"
                            Write-Host "    openclaw gateway --port 18789"
                            Write-Host "  Or check the log: $gwLogFile"
                            Write-Host "========================================="
                        }
                    }
                }
                # 超过重试上限后不再尝试，避免日志刷屏
            } elseif (Test-GatewayListening) {
                # Gateway 正在运行，如果之前有失败计数，重置它
                if ($gwFailCount -gt 0) {
                    Write-Host "[$(Get-Date -Format 'HH:mm:ss')] Gateway is back online, resetting fail counter"
                    $gwFailCount = 0
                }
            }

            # ---- 每30分钟执行一次备份 ----
            if (($elapsed - $lastBackup) -ge $backupInterval) {
                $runMin = [math]::Round($elapsed / 60)
                Write-Host "[$(Get-Date -Format 'HH:mm:ss')] Periodic backup (running ${runMin}min)..."
                try {
                    & $scriptPath -BackupPAT $env:BACKUP_PAT -BackupRepo $env:BACKUP_REPO
                }
                catch {
                    Write-Host "Backup failed: $_"
                }
                $lastBackup = $elapsed
            }
        }

        Write-Host "building finished"

    # ========== 最终备份（无论正常退出、取消、超时都会执行） ==========

    - name: Final State Backup
      if: always()
      env:
        BACKUP_PAT: ${{ secrets.OPENCLAW_BACKUP_PAT }}
        BACKUP_REPO: ${{ secrets.OPENCLAW_BACKUP_REPO }}
      run: |
        Write-Host "Running final state backup..."
        $scriptPath = "$env:GITHUB_WORKSPACE\backup-openclaw-state.ps1"

        if (Test-Path $scriptPath) {
            & $scriptPath -BackupPAT $env:BACKUP_PAT -BackupRepo $env:BACKUP_REPO
        } else {
            # 内联兜底备份（当备份脚本还没创建时）
            $stateDir = "$env:USERPROFILE\.openclaw"
            if (-not (Test-Path $stateDir)) {
                Write-Host "No OpenClaw state to backup"
                exit 0
            }
            if (-not $env:BACKUP_PAT -or -not $env:BACKUP_REPO) {
                Write-Host "Backup secrets not configured, skipping"
                exit 0
            }
            $archiveBase = "$env:TEMP\openclaw-state.7z"
            $tempRepo = "$env:TEMP\openclaw-final-backup"
            try {
                $tempCopy = "$env:TEMP\openclaw-copy-final"
                if (Test-Path $tempCopy) { Remove-Item -Recurse -Force $tempCopy }
                robocopy $stateDir $tempCopy /E /R:0 /W:0 /XF *.lock *.tmp /NFL /NDL /NJH /NJS /NS /NC | Out-Null
                Get-Item "$env:TEMP\openclaw-state.7z*" -ErrorAction SilentlyContinue | Remove-Item -Force
                & 7z a -v95m -mx=7 -mmt=on $archiveBase "$tempCopy\*" | Out-Null
                Remove-Item -Recurse -Force $tempCopy -ErrorAction SilentlyContinue
                $inlineArchives = @(Get-Item "$env:TEMP\openclaw-state.7z.*")
                $inlineTotalSize = [math]::Round(($inlineArchives | Measure-Object -Property Length -Sum).Sum / 1MB, 2)
                Write-Host "Compressed: $inlineTotalSize MB ($($inlineArchives.Count) part(s))"
                $inlineArchives | ForEach-Object { Write-Host "  Part: $($_.Name) ($([math]::Round($_.Length / 1MB, 2)) MB)" }
                git clone --depth 1 "https://$env:BACKUP_PAT@github.com/$env:BACKUP_REPO.git" $tempRepo 2>$null
                if ($LASTEXITCODE -eq 0) {
                    # 清理仓库中的旧格式文件
                    Remove-Item "$tempRepo\openclaw-state.zip" -Force -ErrorAction SilentlyContinue
                    Get-Item "$tempRepo\openclaw-state.7z*" -ErrorAction SilentlyContinue | Remove-Item -Force
                    # 复制新的 7z 分片
                    $inlineArchives | ForEach-Object { Copy-Item $_.FullName $tempRepo -Force }
                    # 校验复制完整性
                    $inlineCopied = @(Get-Item "$tempRepo\openclaw-state.7z.*")
                    if ($inlineCopied.Count -ne $inlineArchives.Count) {
                        Write-Host "WARNING: Copy mismatch ($($inlineCopied.Count)/$($inlineArchives.Count)), retrying..."
                        $inlineArchives | ForEach-Object { Copy-Item $_.FullName $tempRepo -Force }
                    }
                    Push-Location $tempRepo
                    git config user.email "actions@github.com"
                    git config user.name "GitHub Actions"
                    git add -A
                    $finalMsg = "Final backup $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') [$($inlineArchives.Count) parts, ${inlineTotalSize}MB]"
                    git commit -m $finalMsg 2>&1 | Out-Null
                    if ($LASTEXITCODE -eq 0) {
                        git push 2>&1 | Out-Null
                        if ($LASTEXITCODE -ne 0) {
                            Write-Host "Push failed, retrying..."
                            Start-Sleep -Seconds 5
                            git push 2>&1 | Out-Null
                        }
                        if ($LASTEXITCODE -eq 0) {
                            Write-Host "Final backup pushed: $finalMsg"
                        } else {
                            Write-Host "Final backup push failed after retry"
                        }
                    }
                    Pop-Location
                    # 推送后校验远程分片完整性
                    if ($LASTEXITCODE -eq 0) {
                        $verifyDir = "$env:TEMP\openclaw-final-verify"
                        try {
                            git clone --depth 1 "https://$env:BACKUP_PAT@github.com/$env:BACKUP_REPO.git" $verifyDir 2>&1 | Out-Null
                            if ($LASTEXITCODE -eq 0) {
                                $remoteFiles = @(Get-Item "$verifyDir\openclaw-state.7z.*" -ErrorAction SilentlyContinue)
                                if ($remoteFiles.Count -eq $inlineArchives.Count) {
                                    Write-Host "VERIFIED OK: Remote has $($remoteFiles.Count)/$($inlineArchives.Count) part(s)"
                                } else {
                                    Write-Host "VERIFY FAILED: Remote has $($remoteFiles.Count) but expected $($inlineArchives.Count) part(s)!"
                                }
                            }
                        } finally {
                            Remove-Item -Recurse -Force $verifyDir -ErrorAction SilentlyContinue
                        }
                    }
                }
            }
            catch {
                Write-Host "Inline backup error: $_"
            }
            finally {
                if (Test-Path $tempRepo) {
                    Remove-Item -Recurse -Force $tempRepo -ErrorAction SilentlyContinue
                }
            }
        }
        Write-Host "Final backup complete"
