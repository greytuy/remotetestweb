name: Build Workflow

on:
  workflow_dispatch:

jobs:
  build:
    name: Build Stage
    runs-on: windows-latest
    timeout-minutes: 9999
    permissions:
      actions: write
      contents: read

    steps:
    - name: Checkout
      uses: actions/checkout@v2

    - name: Delete old workflow runs
      uses: Mattraks/delete-workflow-runs@v2
      with:
        token: ${{ github.token }}
        repository: ${{ github.repository }}
        retain_days: 3
        keep_minimum_runs: 3

    - name: Setup Utilities
      run: |
        Invoke-WebRequest -Uri https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-windows-amd64.exe -OutFile cloudflared.exe
        .\cloudflared.exe --version

    - name: Adjust Settings
      run: |
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name 'fDenyTSConnections' -Value 0
        Enable-NetFirewallRule -DisplayGroup 'Remote Desktop'
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name 'UserAuthentication' -Value 1

    - name: Update Credentials
      run: |
        $Password = "${{ secrets.RDP_PASSWORD }}"
        # 验证密码复杂性
        if ($Password.Length -lt 12 -or 
            -not ($Password -match '[A-Z]') -or 
            -not ($Password -match '[a-z]') -or 
            -not ($Password -match '\d') -or 
            -not ($Password -match '[^A-Za-z0-9]')) {
            Write-Error "密码格式错误，构建失败"
            exit 1
        }
        $SecurePassword = ConvertTo-SecureString $Password -AsPlainText -Force
        Set-LocalUser -Name "runneradmin" -Password $SecurePassword
        Write-Host "密码已设置完成"

    - name: Start Service
      run: |
        $TunnelToken = "${{ secrets.TUNNEL_TOKEN }}"
        # 验证Token格式
        if (-not ($TunnelToken -match '^eyJ')) {
            Write-Error "Token格式无效，必须以'eyJ'开头"
            exit 1
        }
        Write-Host "正在安装服务..."
        .\cloudflared.exe service install $TunnelToken
        if ($LASTEXITCODE -ne 0) {
            Write-Error "服务安装失败"
            exit 1
        }
        Write-Host "等待服务启动..."
        Start-Sleep -Seconds 5
        Start-Service cloudflared
        if ($?) {
            Write-Host "服务已成功启动"
        } else {
            Write-Error "服务启动失败"
            exit 1
        }

    # ========== OpenClaw 集成 ==========

    - name: Install OpenClaw
      run: |
        Write-Host "正在安装 OpenClaw..."
        npm install -g openclaw@latest
        openclaw --version
        Write-Host "OpenClaw 安装完成"

    - name: Create Backup Script
      run: |
        $scriptContent = @'
        param(
            [Parameter(Mandatory=$true)][string]$BackupPAT,
            [Parameter(Mandatory=$true)][string]$BackupRepo
        )

        $ErrorActionPreference = "Continue"
        $stateDir = "$env:USERPROFILE\.openclaw"
        $tempRepo = "$env:TEMP\openclaw-backup-$(Get-Random)"
        $zipPath = "$env:TEMP\openclaw-state.zip"

        if (-not $BackupPAT -or -not $BackupRepo) {
            Write-Host "Backup secrets not configured, skipping"
            return
        }

        if (-not (Test-Path $stateDir)) {
            Write-Host "State directory not found at $stateDir, skipping backup"
            return
        }

        try {
            Write-Host "Compressing state directory..."
            # 先用 robocopy 复制到临时目录，跳过被锁定的文件和临时文件
            $tempCopy = "$env:TEMP\openclaw-copy-$(Get-Random)"
            if (Test-Path $tempCopy) { Remove-Item -Recurse -Force $tempCopy }
            robocopy $stateDir $tempCopy /E /R:0 /W:0 /XF *.lock *.tmp /NFL /NDL /NJH /NJS /NS /NC | Out-Null
            # robocopy 退出码 0-7 均为成功
            if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
            Compress-Archive -Path "$tempCopy\*" -DestinationPath $zipPath -Force
            Remove-Item -Recurse -Force $tempCopy -ErrorAction SilentlyContinue
            $zipSize = [math]::Round((Get-Item $zipPath).Length / 1MB, 2)
            Write-Host "Compressed: $zipSize MB"

            Write-Host "Cloning backup repository..."
            $cloneOut = git clone --depth 1 "https://${BackupPAT}@github.com/${BackupRepo}.git" $tempRepo 2>&1
            if ($LASTEXITCODE -ne 0) {
                Write-Host "Clone failed - ensure repo exists and PAT has repo access"
                Write-Host $cloneOut
                return
            }

            Copy-Item $zipPath "$tempRepo\openclaw-state.zip" -Force
            Push-Location $tempRepo
            git config user.email "actions@github.com"
            git config user.name "GitHub Actions"
            git add -A
            $msg = "Backup $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
            git commit -m $msg 2>&1 | Out-Null
            if ($LASTEXITCODE -eq 0) {
                git push 2>&1 | Out-Null
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "Backup pushed: $msg"
                } else {
                    Write-Host "Push failed"
                }
            } else {
                Write-Host "No changes to commit"
            }
            Pop-Location
        }
        catch {
            Write-Host "Backup error: $_"
        }
        finally {
            if (Test-Path variable:tempRepo) {
                if (Test-Path $tempRepo) {
                    Remove-Item -Recurse -Force $tempRepo -ErrorAction SilentlyContinue
                }
            }
        }
        '@
        $scriptPath = "$env:GITHUB_WORKSPACE\backup-openclaw-state.ps1"
        Set-Content -Path $scriptPath -Value $scriptContent -Encoding UTF8
        Write-Host "Backup script created at: $scriptPath"

    - name: Restore OpenClaw State
      env:
        BACKUP_PAT: ${{ secrets.OPENCLAW_BACKUP_PAT }}
        BACKUP_REPO: ${{ secrets.OPENCLAW_BACKUP_REPO }}
      run: |
        $stateDir = "$env:USERPROFILE\.openclaw"
        $tempRepo = "$env:TEMP\openclaw-restore-$(Get-Random)"

        # 配置 git（后续备份步骤也需要）
        git config --global user.email "actions@github.com"
        git config --global user.name "GitHub Actions"

        if (-not $env:BACKUP_PAT -or -not $env:BACKUP_REPO) {
            Write-Host "Backup secrets not configured, skipping restore"
            Write-Host "Please connect via RDP and run: openclaw onboard"
            exit 0
        }

        Write-Host "Cloning backup repository..."
        $cloneOut = git clone --depth 1 "https://$env:BACKUP_PAT@github.com/$env:BACKUP_REPO.git" $tempRepo 2>&1

        if ($LASTEXITCODE -eq 0 -and (Test-Path "$tempRepo\openclaw-state.zip")) {
            Write-Host "Found previous backup, restoring..."
            if (-not (Test-Path $stateDir)) {
                New-Item -ItemType Directory -Path $stateDir -Force | Out-Null
            }
            Expand-Archive -Path "$tempRepo\openclaw-state.zip" -DestinationPath $stateDir -Force
            Write-Host "State restored to $stateDir"
        } else {
            Write-Host "========================================="
            Write-Host "  No previous backup found"
            Write-Host "  This appears to be the first run"
            Write-Host "  Please connect via RDP and run:"
            Write-Host "    openclaw onboard"
            Write-Host "========================================="
        }

        if (Test-Path $tempRepo) {
            Remove-Item -Recurse -Force $tempRepo -ErrorAction SilentlyContinue
        }

    # ========== 启动 Gateway + 带定时备份的监控循环 ==========

    - name: Monitor and Periodic Backup
      env:
        BACKUP_PAT: ${{ secrets.OPENCLAW_BACKUP_PAT }}
        BACKUP_REPO: ${{ secrets.OPENCLAW_BACKUP_REPO }}
      run: |
        $backupInterval = 1800   # 30 minutes
        $maxRuntime = 20700      # 5h45m (leave 15min for cleanup before 6h limit)
        $elapsed = 0
        $lastBackup = 0
        $scriptPath = "$env:GITHUB_WORKSPACE\backup-openclaw-state.ps1"
        $configPath = "$env:USERPROFILE\.openclaw\openclaw.json"
        $gwLogFile = "$env:TEMP\openclaw-gw.log"
        $gwFailCount = 0
        $gwMaxFails = 5           # 连续失败 5 次后停止自动重启

        # ---- 检测端口是否有进程在监听 ----
        function Test-GatewayListening {
            $conn = Get-NetTCPConnection -LocalPort 18789 -State Listen -ErrorAction SilentlyContinue
            return ($null -ne $conn)
        }

        # ---- 杀掉占用 18789 端口的旧进程 ----
        function Stop-GatewayProcess {
            $conns = Get-NetTCPConnection -LocalPort 18789 -ErrorAction SilentlyContinue
            foreach ($c in $conns) {
                try { Stop-Process -Id $c.OwningProcess -Force -ErrorAction SilentlyContinue } catch {}
            }
        }

        # ---- 用 cmd.exe 启动 Gateway（避免 .cmd 不是有效 Win32 程序的问题） ----
        function Start-Gateway {
            # 杀旧进程
            Stop-GatewayProcess
            Start-Sleep -Seconds 2

            # 清理旧日志
            if (Test-Path $gwLogFile) { Remove-Item $gwLogFile -Force -ErrorAction SilentlyContinue }

            # 用 cmd.exe 启动（cmd.exe 是真正的 Win32 可执行文件，可以处理 .cmd 包装器）
            # 输出重定向写在 cmd 命令行里，不经过 PowerShell 管道
            # 不用 --force（它依赖 lsof，是 Linux 工具，Windows 上没有）
            # 端口清理已由上面的 Stop-GatewayProcess 完成
            Start-Process -FilePath "cmd.exe" `
                -ArgumentList "/c", "openclaw gateway --port 18789 > `"$gwLogFile`" 2>&1" `
                -WindowStyle Hidden

            # 等待最多 30 秒检测端口是否开始监听
            for ($wait = 1; $wait -le 10; $wait++) {
                Start-Sleep -Seconds 3
                if (Test-GatewayListening) {
                    Write-Host "Gateway listening on port 18789 (started in $($wait*3)s)"
                    return $true
                }
            }

            # 启动失败，输出日志帮助诊断
            Write-Host "Gateway failed to start listening within 30 seconds"
            if (Test-Path $gwLogFile) {
                $logLines = Get-Content $gwLogFile -Tail 20 -ErrorAction SilentlyContinue
                if ($logLines) {
                    Write-Host "--- Gateway log (last 20 lines) ---"
                    $logLines | ForEach-Object { Write-Host "  $_" }
                    Write-Host "--- end log ---"
                }
            }
            return $false
        }

        Write-Host "Building..."

        # ---- 导出环境变量到 .env（解决非交互会话缺少环境变量的问题） ----
        $envFile = "$env:USERPROFILE\.openclaw\.env"
        if (Test-Path "$env:USERPROFILE\.openclaw") {
            # 如果 .env 不存在就创建一个空的，确保 gateway 能加载
            if (-not (Test-Path $envFile)) {
                New-Item -ItemType File -Path $envFile -Force | Out-Null
                Write-Host "Created empty .env file for OpenClaw"
            }
        }

        # ---- 启动 OpenClaw Gateway（如果配置存在） ----
        if (Test-Path $configPath) {
            Write-Host "Config found, starting OpenClaw Gateway on port 18789..."
            $gwStarted = Start-Gateway
            if (-not $gwStarted) {
                $gwFailCount++
                Write-Host "Initial gateway start failed ($gwFailCount/$gwMaxFails)"
            }
        } else {
            Write-Host "No config found, skipping Gateway auto-start"
            Write-Host "========================================="
            Write-Host "  Please connect via RDP and run:"
            Write-Host "    openclaw onboard"
            Write-Host "  Then start the gateway:"
            Write-Host "    openclaw gateway --port 18789"
            Write-Host "========================================="
        }

        while ($elapsed -lt $maxRuntime) {
            Start-Sleep -Seconds 60
            $elapsed += 60

            # ---- 检测 Gateway 是否存活（用端口监听判断，比进程状态更可靠） ----
            if ((Test-Path $configPath) -and -not (Test-GatewayListening)) {
                if ($gwFailCount -lt $gwMaxFails) {
                    Write-Host "[$(Get-Date -Format 'HH:mm:ss')] Gateway not listening on port 18789, restarting... (attempt $($gwFailCount+1)/$gwMaxFails)"
                    $gwStarted = Start-Gateway
                    if ($gwStarted) {
                        $gwFailCount = 0   # 成功启动则重置计数器
                    } else {
                        $gwFailCount++
                        if ($gwFailCount -ge $gwMaxFails) {
                            Write-Host "========================================="
                            Write-Host "  Gateway failed $gwMaxFails times, stopping auto-restart"
                            Write-Host "  Please connect via RDP and start manually:"
                            Write-Host "    openclaw gateway --port 18789"
                            Write-Host "  Or check the log: $gwLogFile"
                            Write-Host "========================================="
                        }
                    }
                }
                # 超过重试上限后不再尝试，避免日志刷屏
            } elseif (Test-GatewayListening) {
                # Gateway 正在运行，如果之前有失败计数，重置它
                if ($gwFailCount -gt 0) {
                    Write-Host "[$(Get-Date -Format 'HH:mm:ss')] Gateway is back online, resetting fail counter"
                    $gwFailCount = 0
                }
            }

            # ---- 每30分钟执行一次备份 ----
            if (($elapsed - $lastBackup) -ge $backupInterval) {
                $runMin = [math]::Round($elapsed / 60)
                Write-Host "[$(Get-Date -Format 'HH:mm:ss')] Periodic backup (running ${runMin}min)..."
                try {
                    & $scriptPath -BackupPAT $env:BACKUP_PAT -BackupRepo $env:BACKUP_REPO
                }
                catch {
                    Write-Host "Backup failed: $_"
                }
                $lastBackup = $elapsed
            }
        }

        Write-Host "Approaching 6-hour GitHub Actions limit, exiting monitor loop"

    # ========== 最终备份（无论正常退出、取消、超时都会执行） ==========

    - name: Final State Backup
      if: always()
      env:
        BACKUP_PAT: ${{ secrets.OPENCLAW_BACKUP_PAT }}
        BACKUP_REPO: ${{ secrets.OPENCLAW_BACKUP_REPO }}
      run: |
        Write-Host "Running final state backup..."
        $scriptPath = "$env:GITHUB_WORKSPACE\backup-openclaw-state.ps1"

        if (Test-Path $scriptPath) {
            & $scriptPath -BackupPAT $env:BACKUP_PAT -BackupRepo $env:BACKUP_REPO
        } else {
            # 内联兜底备份（当备份脚本还没创建时）
            $stateDir = "$env:USERPROFILE\.openclaw"
            if (-not (Test-Path $stateDir)) {
                Write-Host "No OpenClaw state to backup"
                exit 0
            }
            if (-not $env:BACKUP_PAT -or -not $env:BACKUP_REPO) {
                Write-Host "Backup secrets not configured, skipping"
                exit 0
            }
            $zipPath = "$env:TEMP\openclaw-state.zip"
            $tempRepo = "$env:TEMP\openclaw-final-backup"
            try {
                $tempCopy = "$env:TEMP\openclaw-copy-final"
                if (Test-Path $tempCopy) { Remove-Item -Recurse -Force $tempCopy }
                robocopy $stateDir $tempCopy /E /R:0 /W:0 /XF *.lock *.tmp /NFL /NDL /NJH /NJS /NS /NC | Out-Null
                if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
                Compress-Archive -Path "$tempCopy\*" -DestinationPath $zipPath -Force
                Remove-Item -Recurse -Force $tempCopy -ErrorAction SilentlyContinue
                git clone --depth 1 "https://$env:BACKUP_PAT@github.com/$env:BACKUP_REPO.git" $tempRepo 2>$null
                if ($LASTEXITCODE -eq 0) {
                    Copy-Item $zipPath "$tempRepo\openclaw-state.zip" -Force
                    Push-Location $tempRepo
                    git config user.email "actions@github.com"
                    git config user.name "GitHub Actions"
                    git add -A
                    git commit -m "Final backup $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')" 2>&1 | Out-Null
                    git push 2>&1 | Out-Null
                    Pop-Location
                }
            }
            catch {
                Write-Host "Inline backup error: $_"
            }
            finally {
                if (Test-Path $tempRepo) {
                    Remove-Item -Recurse -Force $tempRepo -ErrorAction SilentlyContinue
                }
            }
        }
        Write-Host "Final backup complete"
